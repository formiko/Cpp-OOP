# 对运算符进行重载
## 4.1 为什么要对运算符重载
## 4.2 对运算符重载的方法
* 运算符重载的方法是定义一个重载运算符的函数。在使用被重载的运算符时，系统就自动调用该函数，以实现相应的功能。运算符重载实质上是函数的重载。
* 重载运算符的函数一般格式如下：
	``` C++
	函数类型 operator  运算符名称(形参表)
	{ 对运算符的重载处理 }
	```
* 如，想将“+”用于Complex类（复数）的加法运算，函数的原型可以是这样的：
	``` C++
	Complex operator + (Complex& c1, Complex& c2);
	```
* 注意：函数名是由operator和运算符组成的。上面的“operator+”就是函数名，意思是“对运算符+重载的函数”。这类函数和其他函数在形式上没有什么区别。
## 4.3 重载运算符的规则
1. C++ 不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载。
2. C++允许重载的运算符。不能重载的运算符有5个:
	```
	.	成员访问运算符
	*	成员指针访问运算符
	::	域运算符
	sizeof	长度运算符
	?:	条件运算符
	```
3. 重载不能改变运算符运算对象（即操作数）的个数
4. 重载不能改变运算符的优先级别
5. 重载不能改变运算符的结合性
6. 重载运算符的函数不能有默认的参数（否则就改变了运算符参数的个数）
7. 重载的运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象（或类对象的引用）。也就是说，参数不能全部是C++的标准类型，以防止用户修改用于标准类型数据的运算符的性质。
8. 用于类对象的运算符一般必须重载，但有两个例外，运算符“=”和“&”不必用户重载。
	1. “=”，用户可以认为它是系统提倡的默认的对象赋值运算符，可以直接用于对象间的赋值，不必自己进行重载。但是有时候系统提供的默认的对象赋值运算符不能满足程序的要求，例如，数据成员中包含指向动态分配内存的指针成员时，这种情况需要自己重载赋值运算符。
	2. “&”，不必重载，它能返回类对象在内存中的起始地址。
9. 从理论上说，可以将一个运算符重载为执行任意的操作，如可以将加法运算符重载为输出对象中的信息，将“>”运算符重载为“<”运算。但这样使人莫名其妙。应当使重载运算符的功能类似于该运算符作用域标准类型数据时所实现的功能。


# 第3章 怎样使用类和对象
## 3.1 利用构造函数对类对象进行初始化
### 3.1.1 对象的初始化
*	如果一个类中的所有成员都是公用的，则可以在定义对象时对数据成员进行初始化。如
	``` C++
	class Time {
		public:
			int hour, minute, sec;
	};

	Time t1 = {14, 56, 30};
	```
	但是，如果数据成员是私有的，或者类中有private或protected的数据成员，就不能用这种方法初始化。
### 3.1.2 用构造函数实现对数据成员的初始化
* 构造函数一般声明为public。
* 如果用户自己没有定义构造函数，则C++系统会自动生成一个构造函数，只是这个构造函数函数体是空的，也没有参数，不执行初始化操作。
### 3.1.3 带参数的构造函数
### 3.1.4 用参数初始化表对数据成员初始化
*	这种方法不在函数体内对数据成员初始化，而是在函数首部实现，如：
	``` C++
	Box:Box(int h, int w, int len):height(h),width(w),length(len){}
	```
	个人疑问：参数化初始表中，形参名和数据成员名可以相同吗？
	测试后目前认为可以相同：
	``` C++
	#include <iostream>
	#include <string>
	using namespace std;
	
	class Box {
			int height, width, length;
		public:
			Box(int height, int width, int length): height(height), width(width), length(length) {}
			void show() {
				cout << height << " " << width << " " << length << endl;
			}
	};
	
	int main() {
		Box b(1, 2, 3);
		b.show();
		return 0;
	}
	```
	输出
	```
	1 2 3

	```
*	带有参数初始化表的构造函数的一般形式如下：
  	``` C++
	类名::构造函数名([参数表])[:成员初始化表]
  	{
		[构造函数体]
	}
	```
* 如果数据成员是数组，则应当在构造函数的函数体中用语句对其赋值，而不能在参数初始化表中对其初始化。
### 3.1.5 构造函数的重载
### 3.1.6 使用默认参数的构造函数
## 3.2 利用析构函数进行清理工作
* 如果用new运算符动态地建立了一个对象，当用delete运算符释放该对象时，先调用该对象的析构函数
* 析构函数没有函数参数
* 书中未提：析构函数一般声明为public。
## 3.3 调用构造函数和析构函数的顺序
* 对于同一存储类别的对象而言：先构造的后析构，后构造的先析构
* 如果一个程序包含多个文件，而在不同的文件中都定义了全局对象，则这些对象的构造函数的执行顺序是不确定的。
## 3.4 对象数组
* 如果构造函数只有一个参数，在定义数组时可以直接在等号后面的花括号内提供实参。如
	``` C++
	Student stud[3] = {60, 70, 80};
	```
* 如果构造函数有多个参数，则不能用在定义数组时直接提供所有实参的方法，因为一个数组有多个元素，对每个元素要提供多个实参，如果再考虑到构造函数有默认参数的情况，很容易造成实参与形参的对应关系不清晰，出现歧义性。如：类Student的构造函数有多个参数，且为默认参数
	``` C++
	Student::Student(int=1001,int=18,int=60);
	```
  如果定义对象数组的语句为
  	``` C++
	Student stud[3] = {1005, 60, 70};
	```
  这三个实参分别作为3个元素的第一个实参。在程序中最好不要采用这种容易引起歧义性的方法。
* 如果构造函数有多个参数，定义对象数组时的初始化方法是：在花括号中分别写出构造函数名并在括号内指定实参。如：
	``` C++
	Student Stud[3] = {
		Student(1001,18,87),
		Student(1002,19,76),
		Student(1003,18,72)
	}
	```
## 3.5 对象指针
### 3.5.1 指向对象的指针
``` C++
类名 *对象指针名;
```
### 3.5.2 指向对象成员的指针
1. 指向对象数据成员的指针
``` C++
数据类型名 *指针变量名;
```
2. 指向对象成员函数的指针
	* 普通函数的指针变量定义方法
		``` C++
		类型名(*指针变量名)(参数表列);
		```
	* 定义指向公用成员函数的指针变量的一般形式为：
		``` C++
		数据类型名(类名::*指针变量名)(参数表列);
		```
		使指针指向一个公用成员函数的一般形式为：
			``` C++
			指针变量名=&类名::成员函数名;
			```
			在Visual C++，也可以不写&，以和C语言的用法一致，但建议在写C++程序时不要省略&。  
		注意的是：成员函数的入口地址是`&类名::成员函数名`，理由是成员函数不是存放在对象的空间中的，而是存放在对象外的空间中的。而调用指针指向的成员函数，却用的是`对象名.*指针`的形式。（个人困惑：为什么不能通过类名调用，是因为那就变成静态成员函数了吗？）
### 3.5.3 指向当前对象的this指针
* 每个对象中的数据成员都分别占优存储空间，如果对同一个类定义了n个对象，则有n组同样打下的空间以存放n个对象中的数据成员。但是，不同的对象都调用同一个函数的目标代码。
* 当不同对象的成员函数引用数据成员时，怎么能保证引用的是所指定的对象的成员呢？在每一个成员函数中都包含一个特殊的指针，这个指针的名字是固定的，称为this。它是指向本类对象的指针，它的值是当前被调用的成员函数所在的对象的起始地址。
* this指针是隐式使用的，它是作为参数被传递给成员函数的。
* 有需要时也可以显示使用this指针。个人感觉在编写构造函数的时候可以用来让形参名和数据成员名相同。
## 3.6 共用数据的保护
### 3.6.1 常对象
* 常对象必须要有初值
* 定义常对象的一般形式为
	``` C++
	类名 const 对象名[(实参表)];
	```
	也可以把const写在最左面：
	``` C++
	const 类名 对象名[(实参表)];
	```
* 如果一个对象被声明为常对象，则通过该对象只能调用它的常成员函数，而不能调用该对象的普通成员函数（除了由系统自动调用的隐式的构造函数和析构函数）
* 如果一定要修改常对象中的某个数据成员的值，可以将该数据成员声明为mutable，如
	``` C++
	mutable int count;
	```
 这样就可以用声明为const的成员函数来修改它的值
### 3.6.2 常对象成员
1. 常数据成员
	* 作用和用法与一般常量相似，用关键字const来声明常数据成员
	* 只能通过构造函数的参数初始化列表对常数据成员进行初始化，任何其他函数都不能对常数据成员赋值。
	* 常对象的数据成员都是常数据成员，因此在定义常对象时，构造函数只能用参数初始化表对常数据成员进行初始化。
2. 常成员函数
	* 如果将成员函数声明为常成员函数，则只能引用本类中的数据成员，而不能修改它们。
	* 声明常成员函数的一般格式为
		``` C++
		类型名 函数名(参数表) const
		```
	* const是函数类型的一部分，在声明函数和定义函数时都要有const关键字，在调用时不必加const
	* 常成员函数不能调用另一个非const成员函数
### 3.6.3 指向对象的常指针
* 将指针变量声明为const型，这样指针变量始终保持为初值，不能改变，即其指向不变。如
	``` C++
	Time t1(10,12,15), t2;
	Time * const ptr1;
	ptr1 = &t1;	//ptr指向对象t1,此后不能再改变指向
	ptr1 = &t2;	//错误，ptr1不能改变指向
	```
  （个人困惑）指向对象的常指针跟普通变量的指针不一样吗？为什么可以在定义的时候不初始化？测试也发现`ptr = &t1;`是不能通过编译的呀。
   也可以在定义指针变量时使之初始化，如将上面第2,3行合并为
   	``` C++
	Time * const ptr1 = &t1;
	```
  (个人困惑）看这意思，还有不定义时就初始化的写法吗？
* 定义指向对象的常指针变量的一般形式为
	``` C++
	类名 * const 指针变量名;
	```
* 用处：如果想将一个指针变量固定地与一个对象相联系（即该指针变量始终指向一个对象），可以将它指定为const型指针变量。这样可以防止误操作，增加安全性。  
  往往用常指针作为函数的形参，目的是不允许在函数执行过程中改变指针变量的值，使其始终指向原来的对象。
### 3.6.4 指向常对象的指针变量
* 回顾指向常变量的指针变量
	* 定义指向常变量的指针变量的一般形式为
		``` C++
		const 类型名 *指针变量名;
		```
	* 如果一个变量已经被声明为常变量，只能用指向常变量的指针变量指向它，而不能用一般的（指向非const型变量的）指针变量去指向它。
	* 指向常变量的指针变量除了可以指向常变量外，还可以指向未被声明为const的变量。此时不能通过此指针变量改变该变量的值。
	* 如果函数的形参是指向普通（非const）变量的指针变量，实参只能用指向普通（非const）变量的指针，而不能用指向const变量的指针，这样，在执行函数的过程中可以改变形参指针变量所指向的变量（也就是实参指针所指向的变量）的值。
* 回到指向常对象的指针变量
	* 如果一个对象已被声明为常对象，只能用指向常对象的指针变量指向它，而不能用一般的（指向非const型对象的）指针变量去指向它。
	* 如果定义了一个指向常对象的指针变量，并使它指向一个非const的对象，则其指向的对象是不能通过该指针变量来改变的。
	* 指向常对象的指针最常用于函数的形参，目的是保护形参指针所指向的对象，使它在函数执行过程中不被修改。
	* 直接用对象名作为形参和实参，虽然修改不会作用在实参对象上，但是要产生实参的拷贝，当对象的规模比较大时，则时间开销和空间开销都可能比较大。因此常用指针作函数参数。
### 3.6.5 对象的常引用
* 可以把引用声明为const，即常引用
* 用处：在C++面向对象程序设计中，经常用常指针和常引用作函数参数。这样既能保证数据安全，使数据不能被随意修改，在调用函数时又不必建立实参的拷贝。每次调用函数建立实参的拷贝时，都要调用复制构造函数，要有时间开销。用常指针和常引用作函数参数，可以提高程序运行效率。
### 3.6.6 const型数据的小结
## 3.7 对象的动态建立和释放
* 无名对象。如果已经定义了一个Box类，可以用下面的方法动态地建立一个对象：
	``` C++
	new Box;
	```
  此时用户无法访问这个对象，因为这个对象既没有对象名，用户也不知道它的地址。
## 3.8 对象的赋值和复制
### 3.8.1 对象的赋值
* 对象之间的赋值也是通过赋值运算符“=”进行的。通过对赋值运算符的重载实现的（个人：默认情况不需要重载吧？）。实际上这个过程是通过成员复制(memberwise copy)来完成的，即将一个对象的成员值一一复制给另一对象的对应成员。
* 对象赋值的一般形式为：
	``` C++
	对象名1 = 对象名2
	```
* 对象的赋值只是对其中数据成员的赋值，而不对成员函数赋值。
* 类的数据成员中不能包括动态分配的数据，否则在赋值时可能出现严重后果。
### 3.8.2 对象的复制
* 用处：有时候需要用到多个完全相同的对象，不用对象的复制的情况下，就需要建立多个同样的对象，并要进行相同的初始化。用以前的办法定义对象（同时初始化）比较麻烦。此外，有时需要将对象在某一瞬时的状态保留下来。
  对象的复制机制：用一个已有的对象快速地复制出多个完全相同的对象。
* 对象的复制的一般形式：
	``` C++
	类名 对象2(对象);
	```
* 在建立对象时调用一个特殊的构造函数——复制构造函数(copy constructor)。这个函数的形式是这样的：
	``` C++
	Box::Box(const Box& b){
		height = b.height;
		width = b.width;
		length = b.length;
	}
	```
* 回顾复制对象的语句：
	``` C++
	Box box2(box1);
	```
  由于在括号内给定的实参是对象，因此编译系统就调用复制构造函数（它的形参也是对象），而不会去调用其他构造函数。
* 如果用户自己未定义复制构造函数，则编译系统会自动提供一个默认的复制构造函数，其作用只是简单地复制类中每个数据成员。
* C++还提供另一种方便用户的复制形式，用赋值号代替括号，其一般形式为
	``` C++
	类名 对象名1 = 对象名2;
	```
  注意对象的复制和3.8.1节介绍的对象的赋值在概念上和语法上的不同。对象的赋值时对一个已经存在的对象赋值，因此必须先定义被赋值的对象，才能进行赋值。而对象的复制则是从无到有地建立一个新对象，并使它与一个已有的对象完全相同（包括对象的结构和成员的值）。
* 普通构造函数和复制构造函数的区别。
	1. 在形式上
		``` C++
		类名(形参表列);		//普通构造函数的声明，如Box(int h, int w, int len);
		类名(类名 & 对象名);	//复制构造函数的声明，如Box(Box &b);
		```
	2. 在建立对象时，实参类型不同。系统会根据实参的类型决定调用普通构造函数或复制构造函数。如
		``` C++
		Box box1(12, 15, 16);
		Box box2(box1);
		```
	3. 在什么情况下被调用
		普通构造函数在程序建立对象时被调用
		复制构造函数在用已有对象复制一个新对象时被调用，在以下3种情况下需要复制对象：
			1. 程序中需要新建立一个对象，并用另一个同类的对象对它初始化。
			2. 当函数的参数为类的对象时。
			3. 函数的返回值是类的对象。在函数调用完毕将返回值带回函数调用处时。此时需要将函数中的对象复制一个临时对象并传给该函数的调用处。  
		以上几种调用复制构造函数，都是由编译系统自动实现的，不必由用户自己去调用，读者只要知道在这些情况下需要调用复制构造函数就可以了。（个人困惑）的确，这几种情况会调用复制构造函数，但是实验发现，在自己声明定义复制构造函数的后，前两种情况下的确是调用的我自己定义的复制构造函数，但是第三种情况，也就是函数返回对象的情况下，调用的不是我自己定义的复制构造函数，并且也没有调用普通构造函数。目前猜测是调用的默认的复制构造函数。
* （个人困惑加发现）在不自己声明定义普通构造函数的情况下，声明定义复制构造函数，这时，用花括号初始化公有数据成员编译不过。


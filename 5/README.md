# 第5章 继承与派生
* 面向对象技术强调软件的可重用性（software reusability）
## 5.1 什么是继承与派生
* 在C++中的可重用性是通过“继承（inheritance）”这一机制实现的。
* 一个新类从已有的类那里获得其已有特性，这种现象称为类的继承。
* 单继承：一个派生类只从一个基类派生
* 多重继承：一个派生类有两个或多个基类。
* 派生类是基类的具体化，而基类则是派生类的抽象。
## 5.2 派生类的声明方式
* 声明派生类的一般形式为
	``` C++
	class 派生类名: [继承方式] 基类名
	{
		派生类新增加的成员
	};
	```
  继承方式包括：public（公用的），private（私有的）和protected（受保护的），继承方式是可选的，如果不写此项，则默认为private（私有的）。
## 5.3 派生类的构成
* 派生类分成两大部分，一部分是从基类继承来的成员，另一部分是在声明派生类时增加的部分。
* 派生类把基类全部的成员（不包括构造函数和析构函数）接收过来，也就是说是没有选择的。
* 可以在派生类中声明一个与基类成员同名的成员，则派生类中的新成员会覆盖基类的同名成员。
## 5.4 派生类成员的访问属性
1. 公用继承：基类的公有成员和保护成员在派生类中保持原有访问属性，其私有成员仍为基类私有。
2. 私有继承：基类的公有成员和保护成员在派生类中成了私有成员。其私有成员仍为基类私有。
3. 受保护的继承：基类的共有成员和保护成员在派生类中成了保护成员，其私有成员仍为基类私有。（保护成员：不能被外界引用，但可以被派生类的成员引用）
### 5.4.1 公用继承
* 有人问：既然是公用继承，为什么不能访问基类的私有成员呢？因为私有成员体现了数据的封装性，隐藏私有成员有利于测试、调试和修改系统。保护私有成员时一条重要的原则。
### 5.4.2 私有继承
* 只须理解：既然声明为私有继承，就表示将原来能被外界引用的成员隐藏起来，不让外界引用，因此私有基类的公用成员和保护成员理所当然地成为派生类中的私有成员。
### 5.4.3 保护成员和保护继承
* 从类的用户角度来看，保护成员等价于私有成员。但有一点与私有成员不同，保护成员可以被派生类的成员函数引用。
### 5.4.4 多级派生时的访问属性
## 5.5 派生类的构造函数和析构函数
### 5.5.1 简单的派生类的构造函数
* 派生类构造函数的一般形式为：
	``` C++
	派生类构造函数名(总参数表): 基类构造函数名(参数表)
	{派生类中新增数据成员初始化语句}
	```
* 实际上，本章介绍的在派生类构造函数中对基类成员初始化，就是在第3章介绍的构造函数初始化表。
* 在建立一个对象时，执行构造函数的顺序是：
	1. 派生类构造函数先调用基类构造函数
	2. 再执行派生类构造函数本身（即派生类构造函数的函数体）
### 5.5.2 有子对象的派生类的构造函数
* 定义派生类构造函数的一般形式为
	``` C++
	派生类构造函数名(总参数表): 基类构造函数名(参数表),子对象名(参数表)
	{派生类中新增数据成员初始化语句}
	```
	执行派生类构造函数的顺序是：
		1. 调用基类构造函数
		2. 调用子对象构造函数
		3. 再执行派生类构造函数本身
### 5.5.3 多层派生时的构造函数
* 不要列出每一层派生类的构造函数，只须写出其上一层派生类（即它的直接基类）的构造函数
### 5.5.4 派生类构造函数的特殊形式
### 5.5.5 派生类的析构函数
* 调用的顺序与构造函数正好相反
## 5.6 多重继承


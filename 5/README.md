# 第5章 继承与派生
* 面向对象技术强调软件的可重用性（software reusability）
## 5.1 什么是继承与派生
* 在C++中的可重用性是通过“继承（inheritance）”这一机制实现的。
* 一个新类从已有的类那里获得其已有特性，这种现象称为类的继承。
* 单继承：一个派生类只从一个基类派生
* 多重继承：一个派生类有两个或多个基类。
* 派生类是基类的具体化，而基类则是派生类的抽象。
## 5.2 派生类的声明方式
* 声明派生类的一般形式为
	``` C++
	class 派生类名: [继承方式] 基类名
	{
		派生类新增加的成员
	};
	```
  继承方式包括：public（公用的），private（私有的）和protected（受保护的），继承方式是可选的，如果不写此项，则默认为private（私有的）。
## 5.3 派生类的构成
* 派生类分成两大部分，一部分是从基类继承来的成员，另一部分是在声明派生类时增加的部分。
* 派生类把基类全部的成员（不包括构造函数和析构函数）接收过来，也就是说是没有选择的。
* 可以在派生类中声明一个与基类成员同名的成员，则派生类中的新成员会覆盖基类的同名成员。
## 5.4 派生类成员的访问属性
1. 公用继承：基类的公有成员和保护成员在派生类中保持原有访问属性，其私有成员仍为基类私有。
2. 私有继承：基类的公有成员和保护成员在派生类中成了私有成员。其私有成员仍为基类私有。
3. 受保护的继承：基类的共有成员和保护成员在派生类中成了保护成员，其私有成员仍为基类私有。（保护成员：不能被外界引用，但可以被派生类的成员引用）
### 5.4.1 公用继承
* 有人问：既然是公用继承，为什么不能访问基类的私有成员呢？因为私有成员体现了数据的封装性，隐藏私有成员有利于测试、调试和修改系统。保护私有成员时一条重要的原则。
### 5.4.2 私有继承
* 只须理解：既然声明为私有继承，就表示将原来能被外界引用的成员隐藏起来，不让外界引用，因此私有基类的公用成员和保护成员理所当然地成为派生类中的私有成员。
### 5.4.3 保护成员和保护继承
* 从类的用户角度来看，保护成员等价于私有成员。但有一点与私有成员不同，保护成员可以被派生类的成员函数引用。
### 5.4.4 多级派生时的访问属性
## 5.5 派生类的构造函数和析构函数
### 5.5.1 简单的派生类的构造函数
* 派生类构造函数的一般形式为：
	``` C++
	派生类构造函数名(总参数表): 基类构造函数名(参数表)
	{派生类中新增数据成员初始化语句}
	```
* 实际上，本章介绍的在派生类构造函数中对基类成员初始化，就是在第3章介绍的构造函数初始化表。
* 在建立一个对象时，执行构造函数的顺序是：
	1. 派生类构造函数先调用基类构造函数
	2. 再执行派生类构造函数本身（即派生类构造函数的函数体）
### 5.5.2 有子对象的派生类的构造函数
* 定义派生类构造函数的一般形式为
	``` C++
	派生类构造函数名(总参数表): 基类构造函数名(参数表),子对象名(参数表)
	{派生类中新增数据成员初始化语句}
	```
	执行派生类构造函数的顺序是：
		1. 调用基类构造函数
		2. 调用子对象构造函数
		3. 再执行派生类构造函数本身
### 5.5.3 多层派生时的构造函数
* 不要列出每一层派生类的构造函数，只须写出其上一层派生类（即它的直接基类）的构造函数
### 5.5.4 派生类构造函数的特殊形式
### 5.5.5 派生类的析构函数
* 调用的顺序与构造函数正好相反
## 5.6 多重继承
### 5.6.1 声明多重继承的方法
### 5.6.2 多重继承派生类的构造函数
*
	``` C++
	派生类构造函数名(总参数表): 基类1构造函数(参数表), 基类2构造函数(参数表), 基类3构造函数(参数表列)
	{派生类中新增数据成员初始化语句}
	```
### 5.6.3 多重继承引起的二义性问题
* 两个基类有同名成员，可以用基类名来限定。
* 同名覆盖：基类和派生类的成员同名，基类的同名成员在派生类中被屏蔽，成为“不可见”的，或者说，派生类新增加的同名成员覆盖了基类的同名成员。
* 如果类A和类B是从同一个基类N派生的，类C多重继承自类A和类B。怎样才能访问A类从基类N继承下来的成员呢？应当通过类N的直接派生类名来指出要访问的是类N的哪一个派生类的基类成员。
### 5.6.4 虚基类
* 虚基类的作用：在继承间接共同基类时只保留一份成员。
* 将类A作为虚基类，方法如下：
	``` C++
	class A
	{...};
	class B: virtual public A
	{...};
	class C: virtual public A
	{...};
	```
  注意：虚基类并不是在声明基类时声明的，而是在声明派生类时，指定继承方式时声明的。因为一个基类可以在生成一个派生类时作为虚基类，而在生成另一个派生类时不作为虚基类
* 声明虚基类的一般形式为：
	``` C++
	class 派生类名: virtual 继承方式 基类名
	```
* 为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类。否则仍然会出现对基类的多次继承。
* 虚基类的初始化：在最后的派生类中不仅要负责对其直接基类进行初始化，还要负责对虚基类初始化。并且，C++编译系统只执行最后的派生类对虚基类的构造函数的调用。
## 5.7 基类与派生类的转换
* 派生类对象可以向基类对象赋值
* 派生类对象可以替代基类对象向基类对象的引用进行赋值或初始化
* 如果函数的参数是基类对象或基类对象的引用，相应的实参可以用子类对象
* 派生类对象的地址可以赋给指向基类对象的指针变量，也就是说，指向基类对象的指针变量也可以用来指向派生类对象。
* 通过指向基类对象的指针，只能访问派生类中的基类成员，而不能访问派生类增加的成员
## 5.8 继承与组合
* 类的组合：在一个类中以另一个类的对象作为数据成员
## 5.9 继承在软件开发中的重要意义
* 基类时单独编译的，在程序编译时只须对派生类新增的功能进行编译，这就大大提高了调试程序的效率。
* 如果在必要时修改了基类，只要基类的公用接口不变，派生类不必修改，但基类需要重新编译，派生类也必须重新编译，否则不起作用。
